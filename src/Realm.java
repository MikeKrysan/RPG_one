/*
При запуске игры пользователю нужно будет первым делом создать персонажа, которого назовет пользователь. После этого у игрока должна появиться надпись Куда вы хотите пойти? и
быть доступны следующие варианты:

1. К торговцу

2. В тёмный лес

3. На выход

Пользователь будет осуществлять выбор введением номера соответствующего пункта.

В первом случае можно будет попасть к торговцу (которого вам нужно реализовать самостоятельно, вместе с логикой взаимодействия с ним; если еще не реализовали — пусть возвращается надпись
(Торговец еще не вышел на работу).

Во втором случае можно будет запустить логику ведения боя. Монстр должен появляться рандомный (либо скелет, либо гоблин с вероятностью 50%).

По завершении торговли или завершении боя должна быть доступна опция Вернуться в город или Продолжить торговлю/бой.
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;


public class Realm {    //6
    //класс для чтения введенных строк из консоли
    private static BufferedReader br;       //6.1.
    //Игрок должен храниться на протяжении всей игры
    private static FantasyCharacter player = null;     //6.1.
    //Класс для битвы можно не создавать каждый раз, а переисполнять
    private static BattleScene battleScene = null;      //6.1.

    public static void main(String[] args) {    //6.2.
        //Инициализируем BufferedReader
        br = new BufferedReader(new InputStreamReader(System.in));
        //Инициализируем класс для боя
        battleScene = new BattleScene();
        //первое, что нужно сделать при запуске игры, это создать персонажа, поэтому мы предлагаем ввести его имя
        System.out.println("Введите имя персонажа:");
        //Далее ждем ввод от пользователя
        try {
            command(br.readLine()); //6.2.    QA
        } catch (IOException e) {
        }
    }

    private static void command(String string) throws IOException { //6.3 В параметры метода мы передаем считанные значения с консоли (имя), и задаем также следующие характеристики:
        //Если это первый запуск, то мы должны создать игрока, именем будет служить первая выделенная строка из консоли
        if (player == null) {
            player = new Hero(
                    string,
                    100,
                    20,
                    20,
                    0,
                    0
            );
            System.out.println(String.format("Спасти наш мир от драконов вызвался %s! Да будет его броня крепка и бицепс кругл!", player.getName()));
            //метод для вывода меню
            printNavigation();  //6.4.
        }

        //варианты для команд
        switch (string) {
            case "1": {
                System.out.println("Торговец еще не приехал");
                command(br.readLine());
            }
            break;
            case "2": {
                commitFight();  //6.5 этот вариант ведет нас к запуску боевой логики, реализация которой в методе commitFight()
            }
            break;
            case "3":
                System.exit(1);
            break;
            case "да":                  //6.7
                command("2");
            break;
            case "нет": {               //6.7
                printNavigation();
                command(br.readLine());
            }
        }
        //снова ждем команды от пользователя
        command(br.readLine());
    }

    public static void commitFight() {  //6.5 здесь мы анонимно реализуем класс из  интерфейса FightCallback
        battleScene.fight(player, createMonster(), new FightCallback() {
            @Override
            public void fightWin() {
                System.out.println(String.format("%s победил! Теперь у вас %d опыта и %d золота, а также осталось %d единиц здоровья.%n", player.getName(), player.getXp(), player.getGold(), player.getHealthPoints()));
                System.out.println("Желаете продолжить поход или вернутся в город? (да/нет)");
                try {
                    command(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            @Override
            public void fightLost() {

            }
        });
    }

    private static void printNavigation() { //6.4
        System.out.println("Куда вы хотите пойти?");
        System.out.println("1. К торговцу");
        System.out.println("2. В темный лес");
        System.out.println("3. Выход");
    }

    private static FantasyCharacter createMonster() {
        //рандомайзер
        int random = (int) (Math.random()*10);
        //с вероятностью 50% создается или скелет или гоблин
        if(random % 2 == 0) return new Goblin (
                "Гоблин",
                50,
                10,
                10,
                100,
                20
        );
        else return new Skeleton (
               "Скелет",
               25,
               20,
               20,
               100,
               10
        );
    }

    public interface FightCallback {    //6.6
        void fightWin();
        void fightLost();
    }

}

/*
6.1. Как вы видите, поля класса статичные. Чтобы нам не создавать этот класс в методе main, так как без этого класса мы все равно не сможем, методы этого класса будут тоже статичными.

6.2. Как мы видим, у нас тут нет никаких циклов и потоков тоже не создается, но тем не менее игра не завершиться, так как в методе command у нас будет реализована рекурсия, то есть повторный вызов метода.

6.4. То есть пользователю нужно ввести номер пункта, который мы также обрабатываем в методе command, а именно в операторе switch:

6.5. Здесь мы запускаем наш бой, передав в метод fight у переменной battleScene нашего героя — player, а также монстра. И коллбэк, который мы тут и реализуем.
Как вы помните, в классе BattleScene мы будем вызывать методы FightCallback, так вот, когда мы их вызываем там, они будут отрабатываться тут, где мы их создали изначально.

6.7 Тут открывается еще одно место для рефакторинга, так как у нас нет ограничения на ввод команд, то есть мы можем их вводить бесконтрольно, вне зависимости от ситуации.
На вопрос «да или нет» мы можем ввести цифру или наоборот, когда нужно ввести цифру, мы можем ввести «да/нет», и это ломает логику. Надо создать ограничения на ввод команд в зависимости от ситуации.
 */